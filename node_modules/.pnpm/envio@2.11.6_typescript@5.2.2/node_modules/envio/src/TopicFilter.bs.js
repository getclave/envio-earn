// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Viem = require("viem");
var $$BigInt = require("./bindings/BigInt.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function toTwosComplement(num, bytesLen) {
  var maxValue = $$BigInt.Bitwise.shift_left(1n, BigInt((bytesLen << 3)));
  var mask = $$BigInt.sub(maxValue, 1n);
  return $$BigInt.Bitwise.logand($$BigInt.add(num, maxValue), mask);
}

function fromSignedBigInt(val) {
  var val$1 = val >= 0n ? val : toTwosComplement(val, 32);
  return Viem.numberToHex(val$1, {
              size: 32
            });
}

function keccak256(prim) {
  return Viem.keccak256(prim);
}

function bytesToHex(prim0, prim1) {
  return Viem.bytesToHex(prim0, prim1 !== undefined ? Caml_option.valFromOption(prim1) : undefined);
}

function concat(prim) {
  return Viem.concat(prim);
}

function castToHexUnsafe(val) {
  return val;
}

function fromBigInt(val) {
  return Viem.numberToHex(val, {
              size: 32
            });
}

function fromDynamicString(val) {
  return Viem.keccak256(val);
}

function fromString(val) {
  return Viem.stringToHex(val, {
              size: 32
            });
}

function fromAddress(addr) {
  return Viem.pad(addr);
}

function fromDynamicBytes(bytes) {
  return Viem.keccak256(bytes);
}

function fromBytes(bytes) {
  return Viem.bytesToHex(bytes, {
              size: 32
            });
}

function fromBool(b) {
  return Viem.boolToHex(b, {
              size: 32
            });
}

exports.toTwosComplement = toTwosComplement;
exports.fromSignedBigInt = fromSignedBigInt;
exports.keccak256 = keccak256;
exports.bytesToHex = bytesToHex;
exports.concat = concat;
exports.castToHexUnsafe = castToHexUnsafe;
exports.fromBigInt = fromBigInt;
exports.fromDynamicString = fromDynamicString;
exports.fromString = fromString;
exports.fromAddress = fromAddress;
exports.fromDynamicBytes = fromDynamicBytes;
exports.fromBytes = fromBytes;
exports.fromBool = fromBool;
/* viem Not a pure module */
