// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Enum = require("../Enum.bs.js");
var Table = require("./Table.bs.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var S$RescriptSchema = require("rescript-schema/src/S.bs.js");

var variants = [
  "SET",
  "DELETE"
];

var name = "ENTITY_HISTORY_ROW_ACTION";

var $$enum = Enum.make(name, variants);

var RowAction = {
  variants: variants,
  name: name,
  $$enum: $$enum
};

var entityIdOnlySchema = S$RescriptSchema.schema(function (s) {
      return {
              id: s.matches(S$RescriptSchema.string)
            };
    });

var previousHistoryFieldsSchema = S$RescriptSchema.object(function (s) {
      return {
              chain_id: s.f("previous_entity_history_chain_id", S$RescriptSchema.$$null(S$RescriptSchema.$$int)),
              block_timestamp: s.f("previous_entity_history_block_timestamp", S$RescriptSchema.$$null(S$RescriptSchema.$$int)),
              block_number: s.f("previous_entity_history_block_number", S$RescriptSchema.$$null(S$RescriptSchema.$$int)),
              log_index: s.f("previous_entity_history_log_index", S$RescriptSchema.$$null(S$RescriptSchema.$$int))
            };
    });

var currentHistoryFieldsSchema = S$RescriptSchema.object(function (s) {
      return {
              chain_id: s.f("entity_history_chain_id", S$RescriptSchema.$$int),
              block_timestamp: s.f("entity_history_block_timestamp", S$RescriptSchema.$$int),
              block_number: s.f("entity_history_block_number", S$RescriptSchema.$$int),
              log_index: s.f("entity_history_log_index", S$RescriptSchema.$$int)
            };
    });

function makeHistoryRowSchema(entitySchema) {
  var nullableEntitySchema = S$RescriptSchema.schema(function (s) {
        var match = S$RescriptSchema.classify(entitySchema);
        if (typeof match !== "object") {
          return Js_exn.raiseError("Failed creating nullableEntitySchema. Expected an object schema for entity");
        }
        if (match.TAG !== "Object") {
          return Js_exn.raiseError("Failed creating nullableEntitySchema. Expected an object schema for entity");
        }
        var nulldict = {};
        Belt_Array.forEach(match.items, (function (param) {
                var $$location = param.l;
                var schema = param.t;
                var match = S$RescriptSchema.classify(schema);
                var nullableFieldSchema = $$location === "id" || !(typeof match !== "object" || match.TAG !== "Null") ? schema : S$RescriptSchema.$$null(schema);
                nulldict[$$location] = s.matches(nullableFieldSchema);
              }));
        return nulldict;
      });
  return S$RescriptSchema.transform(S$RescriptSchema.object(function (s) {
                  return {
                          current: s.flatten(currentHistoryFieldsSchema),
                          previous: s.flatten(previousHistoryFieldsSchema),
                          entityData: s.flatten(nullableEntitySchema),
                          action: s.f("action", $$enum.schema)
                        };
                }), (function (s) {
                return {
                        p: (function (v) {
                            var match = v.previous;
                            var chain_id = match.chain_id;
                            var tmp;
                            var exit = 0;
                            if (chain_id !== undefined) {
                              var block_timestamp = match.block_timestamp;
                              if (block_timestamp !== undefined) {
                                var block_number = match.block_number;
                                if (block_number !== undefined) {
                                  var log_index = match.log_index;
                                  if (log_index !== undefined) {
                                    tmp = {
                                      chain_id: chain_id,
                                      block_timestamp: block_timestamp,
                                      block_number: block_number,
                                      log_index: log_index
                                    };
                                  } else {
                                    exit = 1;
                                  }
                                } else {
                                  exit = 1;
                                }
                              } else {
                                exit = 1;
                              }
                            } else if (match.block_timestamp !== undefined || match.block_number !== undefined || match.log_index !== undefined) {
                              exit = 1;
                            } else {
                              tmp = undefined;
                            }
                            if (exit === 1) {
                              tmp = s.fail("Unexpected mix of null and non-null values in previous history fields", undefined);
                            }
                            var match$1 = v.action;
                            var tmp$1;
                            if (match$1 === "SET") {
                              tmp$1 = {
                                TAG: "Set",
                                _0: v.entityData
                              };
                            } else {
                              var match$2 = v.entityData;
                              tmp$1 = {
                                TAG: "Delete",
                                _0: {
                                  id: match$2.id
                                }
                              };
                            }
                            return {
                                    current: v.current,
                                    previous: tmp,
                                    entityData: tmp$1
                                  };
                          }),
                        s: (function (v) {
                            var entityData = v.entityData;
                            var match;
                            match = entityData.TAG === "Delete" ? [
                                entityData._0,
                                "DELETE"
                              ] : [
                                entityData._0,
                                "SET"
                              ];
                            var historyFields = v.previous;
                            return {
                                    current: v.current,
                                    entityData: match[0],
                                    action: match[1],
                                    previous: historyFields !== undefined ? historyFields : ({
                                          chain_id: undefined,
                                          block_timestamp: undefined,
                                          block_number: undefined,
                                          log_index: undefined
                                        })
                                  };
                          })
                      };
              }));
}

function insertRow(self, sql, historyRow, shouldCopyCurrentEntity) {
  var row = S$RescriptSchema.serializeOrRaiseWith(historyRow, self.schema);
  return self.insertFn(sql, row, shouldCopyCurrentEntity);
}

function batchInsertRows(self, sql, rows, shouldCopyCurrentEntity) {
  var rows$1 = S$RescriptSchema.serializeOrRaiseWith(rows, self.schemaRows);
  return Promise.all(Belt_Array.map(rows$1, (function (row) {
                      return self.insertFn(sql, row, shouldCopyCurrentEntity);
                    }))).then(function (param) {
              
            });
}

function fromTable(table, schema) {
  var currentChangeFieldNames = [
    "entity_history_block_timestamp",
    "entity_history_chain_id",
    "entity_history_block_number",
    "entity_history_log_index"
  ];
  var currentHistoryFields = Belt_Array.map(currentChangeFieldNames, (function (fieldName) {
          return Table.mkField(undefined, undefined, undefined, true, undefined, undefined, fieldName, "INTEGER");
        }));
  var previousChangeFieldNames = Belt_Array.map(currentChangeFieldNames, (function (fieldName) {
          return "previous_" + fieldName;
        }));
  var previousHistoryFields = Belt_Array.map(previousChangeFieldNames, (function (fieldName) {
          return Table.mkField(undefined, undefined, true, undefined, undefined, undefined, fieldName, "INTEGER");
        }));
  var id = "id";
  var dataFields = Belt_Array.keepMap(table.fields, (function (field) {
          if (field.TAG !== "Field") {
            return ;
          }
          var field$1 = field._0;
          var match = field$1.fieldName;
          switch (match) {
            case "db_write_timestamp" :
                return ;
            case "id" :
                return {
                        TAG: "Field",
                        _0: {
                          fieldName: id,
                          fieldType: field$1.fieldType,
                          isArray: field$1.isArray,
                          isNullable: field$1.isNullable,
                          isPrimaryKey: true,
                          isIndex: field$1.isIndex,
                          linkedEntity: field$1.linkedEntity,
                          defaultValue: field$1.defaultValue
                        }
                      };
            default:
              return {
                      TAG: "Field",
                      _0: {
                        fieldName: field$1.fieldName,
                        fieldType: field$1.fieldType,
                        isArray: field$1.isArray,
                        isNullable: true,
                        isPrimaryKey: field$1.isPrimaryKey,
                        isIndex: false,
                        linkedEntity: field$1.linkedEntity,
                        defaultValue: field$1.defaultValue
                      }
                    };
          }
        }));
  var actionFieldName = "action";
  var actionField = Table.mkField(undefined, undefined, undefined, undefined, undefined, undefined, actionFieldName, $$enum.name);
  var serialField = Table.mkField(undefined, undefined, true, undefined, true, undefined, "serial", "SERIAL");
  var dataFieldNames = Belt_Array.map(dataFields, (function (field) {
          return Table.getFieldName(field);
        }));
  var originTableName = table.tableName;
  var historyTableName = originTableName + "_history";
  var table$1 = Table.mkTable(undefined, Belt_Array.concatMany([
            currentHistoryFields,
            previousHistoryFields,
            dataFields,
            [
              actionField,
              serialField
            ]
          ]), historyTableName);
  var insertFnName = "\"insert_" + table$1.tableName + "\"";
  var historyRowArg = "history_row";
  var historyTablePath = "\"public\".\"" + historyTableName + "\"";
  var originTablePath = "\"public\".\"" + originTableName + "\"";
  var previousHistoryFieldsAreNullStr = Belt_Array.map(previousChangeFieldNames, (function (fieldName) {
            return historyRowArg + "." + fieldName + " IS NULL";
          })).join(" OR ");
  var currentChangeFieldNamesCommaSeparated = currentChangeFieldNames.join(", ");
  var dataFieldNamesDoubleQuoted = Belt_Array.map(dataFieldNames, (function (fieldName) {
          return "\"" + fieldName + "\"";
        }));
  var dataFieldNamesCommaSeparated = dataFieldNamesDoubleQuoted.join(", ");
  var allFieldNamesDoubleQuoted = Belt_Array.map(Belt_Array.concatMany([
            currentChangeFieldNames,
            previousChangeFieldNames,
            dataFieldNames,
            [actionFieldName]
          ]), (function (fieldName) {
          return "\"" + fieldName + "\"";
        }));
  var createInsertFnQuery = "CREATE OR REPLACE FUNCTION " + insertFnName + "(" + historyRowArg + " " + historyTablePath + ", should_copy_current_entity BOOLEAN)\n      RETURNS void AS $$\n      DECLARE\n        v_previous_record RECORD;\n        v_origin_record RECORD;\n      BEGIN\n        -- Check if previous values are not provided\n        IF " + previousHistoryFieldsAreNullStr + " THEN\n          -- Find the most recent record for the same id\n          SELECT " + currentChangeFieldNamesCommaSeparated + " INTO v_previous_record\n          FROM " + historyTablePath + "\n          WHERE " + id + " = " + historyRowArg + "." + id + "\n          ORDER BY " + Belt_Array.map(currentChangeFieldNames, (function (fieldName) {
            return fieldName + " DESC";
          })).join(", ") + "\n          LIMIT 1;\n\n          -- If a previous record exists, use its values\n          IF FOUND THEN\n            " + Belt_Array.map(Belt_Array.zip(currentChangeFieldNames, previousChangeFieldNames), (function (param) {
            return historyRowArg + "." + param[1] + " := v_previous_record." + param[0] + ";";
          })).join(" ") + "\n            ElSIF should_copy_current_entity THEN\n            -- Check if a value for the id exists in the origin table and if so, insert a history row for it.\n            SELECT " + dataFieldNamesCommaSeparated + " FROM " + originTablePath + " WHERE id = " + historyRowArg + "." + id + " INTO v_origin_record;\n            IF FOUND THEN\n              INSERT INTO " + historyTablePath + " (" + currentChangeFieldNamesCommaSeparated + ", " + dataFieldNamesCommaSeparated + ", \"" + actionFieldName + "\")\n              -- SET the current change data fields to 0 since we don't know what they were\n              -- and it doesn't matter provided they are less than any new values\n              VALUES (" + Belt_Array.map(currentChangeFieldNames, (function (param) {
            return "0";
          })).join(", ") + ", " + Belt_Array.map(dataFieldNames, (function (fieldName) {
            return "v_origin_record.\"" + fieldName + "\"";
          })).join(", ") + ", 'SET');\n\n              " + Belt_Array.map(previousChangeFieldNames, (function (previousFieldName) {
            return historyRowArg + "." + previousFieldName + " := 0;";
          })).join(" ") + "\n            END IF;\n          END IF;\n        END IF;\n\n        INSERT INTO " + historyTablePath + " (" + allFieldNamesDoubleQuoted.join(", ") + ")\n        VALUES (" + Belt_Array.map(allFieldNamesDoubleQuoted, (function (fieldName) {
            return historyRowArg + "." + fieldName;
          })).join(", ") + ");\n      END;\n      $$ LANGUAGE plpgsql;\n      ";
  var insertFnString = "(sql, rowArgs, shouldCopyCurrentEntity) =>\n      sql\`select " + insertFnName + "(ROW(" + Belt_Array.map(allFieldNamesDoubleQuoted, (function (fieldNameDoubleQuoted) {
            return "\${rowArgs[" + fieldNameDoubleQuoted + "]\}";
          })).join(", ") + ", NULL),  --NULL argument for SERIAL field\n    \${shouldCopyCurrentEntity});\`";
  var insertFn = eval(insertFnString);
  var schema$1 = makeHistoryRowSchema(schema);
  return {
          table: table$1,
          createInsertFnQuery: createInsertFnQuery,
          schema: schema$1,
          schemaRows: S$RescriptSchema.array(schema$1),
          insertFn: insertFn
        };
}

exports.RowAction = RowAction;
exports.entityIdOnlySchema = entityIdOnlySchema;
exports.previousHistoryFieldsSchema = previousHistoryFieldsSchema;
exports.currentHistoryFieldsSchema = currentHistoryFieldsSchema;
exports.makeHistoryRowSchema = makeHistoryRowSchema;
exports.insertRow = insertRow;
exports.batchInsertRows = batchInsertRows;
exports.fromTable = fromTable;
/* enum Not a pure module */
