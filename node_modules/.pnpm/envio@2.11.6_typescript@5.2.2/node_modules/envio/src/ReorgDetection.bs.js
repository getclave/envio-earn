// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_MapInt = require("rescript/lib/js/belt_MapInt.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

function makeWithData(lastBlockScannedDataListArr, confirmedBlockThreshold) {
  return {
          confirmedBlockThreshold: confirmedBlockThreshold,
          lastBlockScannedDataList: Belt_List.reverse(Belt_List.fromArray(lastBlockScannedDataListArr))
        };
}

function empty(confirmedBlockThreshold) {
  return {
          confirmedBlockThreshold: confirmedBlockThreshold,
          lastBlockScannedDataList: /* [] */0
        };
}

function getEarlistTimestampInThreshold(currentHeight, param) {
  var confirmedBlockThreshold = param.confirmedBlockThreshold;
  var _reversedLastBlockDataList = Belt_List.reverse(param.lastBlockScannedDataList);
  while(true) {
    var reversedLastBlockDataList = _reversedLastBlockDataList;
    if (!reversedLastBlockDataList) {
      return ;
    }
    var lastBlockScannedData = reversedLastBlockDataList.hd;
    if (lastBlockScannedData.blockNumber >= (currentHeight - confirmedBlockThreshold | 0)) {
      return lastBlockScannedData.blockTimestamp;
    }
    _reversedLastBlockDataList = reversedLastBlockDataList.tl;
    continue ;
  };
}

function addLatestLastBlockDataInternal(lastBlockScannedData, _accumRevOpt, _lastBlockScannedDataList) {
  while(true) {
    var accumRevOpt = _accumRevOpt;
    var lastBlockScannedDataList = _lastBlockScannedDataList;
    var accumRev = accumRevOpt !== undefined ? accumRevOpt : /* [] */0;
    if (!lastBlockScannedDataList) {
      return Belt_List.reverseConcat(accumRev, {
                  hd: lastBlockScannedData,
                  tl: /* [] */0
                });
    }
    var head = lastBlockScannedDataList.hd;
    if (head.blockNumber <= lastBlockScannedData.blockNumber) {
      return Belt_List.reverseConcat(accumRev, {
                  hd: lastBlockScannedData,
                  tl: lastBlockScannedDataList
                });
    }
    _lastBlockScannedDataList = lastBlockScannedDataList.tl;
    _accumRevOpt = {
      hd: head,
      tl: accumRev
    };
    continue ;
  };
}

function addLatestLastBlockData(param, lastBlockScannedData) {
  return {
          confirmedBlockThreshold: param.confirmedBlockThreshold,
          lastBlockScannedDataList: addLatestLastBlockDataInternal(lastBlockScannedData, undefined, param.lastBlockScannedDataList)
        };
}

function getLatestLastBlockData(self) {
  return Belt_List.head(self.lastBlockScannedDataList);
}

function blockDataIsPastThreshold(lastBlockScannedData, currentHeight, confirmedBlockThreshold) {
  return lastBlockScannedData.blockNumber < (currentHeight - confirmedBlockThreshold | 0);
}

function trampoline(_value) {
  while(true) {
    var value = _value;
    if (value.TAG === "Data") {
      return value._0;
    }
    _value = value._0();
    continue ;
  };
}

function pruneStaleBlockDataInternal(currentHeight, earliestMultiChainTimestampInThreshold, confirmedBlockThreshold, lastBlockScannedDataListReversed) {
  if (earliestMultiChainTimestampInThreshold === undefined) {
    return {
            TAG: "Callback",
            _0: (function () {
                return pruneEarliestBlockData(lastBlockScannedDataListReversed, currentHeight, earliestMultiChainTimestampInThreshold, confirmedBlockThreshold);
              })
          };
  }
  if (!lastBlockScannedDataListReversed) {
    return {
            TAG: "Data",
            _0: lastBlockScannedDataListReversed
          };
  }
  var match = lastBlockScannedDataListReversed.tl;
  if (match && match.hd.blockTimestamp < earliestMultiChainTimestampInThreshold) {
    return {
            TAG: "Callback",
            _0: (function () {
                return pruneEarliestBlockData(lastBlockScannedDataListReversed, currentHeight, earliestMultiChainTimestampInThreshold, confirmedBlockThreshold);
              })
          };
  } else {
    return {
            TAG: "Data",
            _0: lastBlockScannedDataListReversed
          };
  }
}

function pruneEarliestBlockData(lastBlockScannedDataListReversed, currentHeight, earliestMultiChainTimestampInThreshold, confirmedBlockThreshold) {
  if (!lastBlockScannedDataListReversed) {
    return {
            TAG: "Data",
            _0: /* [] */0
          };
  }
  var tail = lastBlockScannedDataListReversed.tl;
  if (blockDataIsPastThreshold(lastBlockScannedDataListReversed.hd, currentHeight, confirmedBlockThreshold)) {
    return {
            TAG: "Callback",
            _0: (function () {
                return pruneStaleBlockDataInternal(currentHeight, earliestMultiChainTimestampInThreshold, confirmedBlockThreshold, tail);
              })
          };
  } else {
    return {
            TAG: "Data",
            _0: lastBlockScannedDataListReversed
          };
  }
}

function pruneStaleBlockData(currentHeight, earliestMultiChainTimestampInThreshold, param) {
  var confirmedBlockThreshold = param.confirmedBlockThreshold;
  return {
          confirmedBlockThreshold: confirmedBlockThreshold,
          lastBlockScannedDataList: Belt_List.reverse(trampoline(pruneStaleBlockDataInternal(currentHeight, earliestMultiChainTimestampInThreshold, confirmedBlockThreshold, Belt_List.reverse(param.lastBlockScannedDataList))))
        };
}

var BlockNotIncludedInMap = /* @__PURE__ */Caml_exceptions.create("ReorgDetection.LastBlockScannedHashes.BlockNotIncludedInMap");

function doBlockHashesMatch(lastBlockScannedData, latestBlockHashes) {
  var blockNumber = lastBlockScannedData.blockNumber;
  var matchingBlock = Belt_MapInt.get(latestBlockHashes, blockNumber);
  if (matchingBlock !== undefined) {
    return {
            TAG: "Ok",
            _0: lastBlockScannedData.blockHash === matchingBlock
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              RE_EXN_ID: BlockNotIncludedInMap,
              _1: blockNumber
            }
          };
  }
}

function rollBackToValidHashInternal(latestBlockScannedData, latestBlockHashes) {
  if (!latestBlockScannedData) {
    return {
            TAG: "Ok",
            _0: /* [] */0
          };
  }
  var tail = latestBlockScannedData.tl;
  var lastBlockScannedData = latestBlockScannedData.hd;
  return Belt_Result.flatMap(doBlockHashesMatch(lastBlockScannedData, latestBlockHashes), (function (blockHashesDoMatch) {
                if (blockHashesDoMatch) {
                  return {
                          TAG: "Ok",
                          _0: {
                            hd: lastBlockScannedData,
                            tl: tail
                          }
                        };
                } else {
                  return rollBackToValidHashInternal(tail, latestBlockHashes);
                }
              }));
}

function rollBackToValidHash(self, blockNumbersAndHashes) {
  var confirmedBlockThreshold = self.confirmedBlockThreshold;
  var latestBlockHashes = Belt_MapInt.fromArray(Belt_Array.map(blockNumbersAndHashes, (function (param) {
              return [
                      param.blockNumber,
                      param.blockHash
                    ];
            })));
  return Belt_Result.map(rollBackToValidHashInternal(self.lastBlockScannedDataList, latestBlockHashes), (function (list) {
                return {
                        confirmedBlockThreshold: confirmedBlockThreshold,
                        lastBlockScannedDataList: list
                      };
              }));
}

function rollBackToBlockNumberLtInternal(blockNumber, _latestBlockScannedData) {
  while(true) {
    var latestBlockScannedData = _latestBlockScannedData;
    if (!latestBlockScannedData) {
      return /* [] */0;
    }
    if (latestBlockScannedData.hd.blockNumber < blockNumber) {
      return latestBlockScannedData;
    }
    _latestBlockScannedData = latestBlockScannedData.tl;
    continue ;
  };
}

function rollBackToBlockNumberLt(blockNumber, self) {
  return {
          confirmedBlockThreshold: self.confirmedBlockThreshold,
          lastBlockScannedDataList: rollBackToBlockNumberLtInternal(blockNumber, self.lastBlockScannedDataList)
        };
}

function getEarliestMultiChainTimestampInThreshold(multiSelf) {
  if (multiSelf.length !== 1) {
    var arrInt = Belt_Array.keepMap(multiSelf, (function (param) {
            return getEarlistTimestampInThreshold(param.currentHeight, param.lastBlockScannedHashes);
          }));
    return Belt_Array.reduce(arrInt, undefined, (function (current, val) {
                  if (current !== undefined) {
                    return Math.min(current, val);
                  } else {
                    return val;
                  }
                }));
  }
  
}

function getAllBlockNumbers(self) {
  return Belt_List.reduceReverse(self.lastBlockScannedDataList, [], (function (acc, v) {
                return Belt_Array.concat(acc, [v.blockNumber]);
              }));
}

function hasReorgOccurred(lastBlockScannedHashes, firstBlockParentNumberAndHash) {
  var _lastBlockScannedDataList = lastBlockScannedHashes.lastBlockScannedDataList;
  while(true) {
    var lastBlockScannedDataList = _lastBlockScannedDataList;
    if (firstBlockParentNumberAndHash === undefined) {
      return false;
    }
    if (!lastBlockScannedDataList) {
      return false;
    }
    var head = lastBlockScannedDataList.hd;
    if (firstBlockParentNumberAndHash.blockNumber === head.blockNumber) {
      return firstBlockParentNumberAndHash.blockHash !== head.blockHash;
    }
    _lastBlockScannedDataList = lastBlockScannedDataList.tl;
    continue ;
  };
}

var LastBlockScannedHashes = {
  makeWithData: makeWithData,
  empty: empty,
  addLatestLastBlockData: addLatestLastBlockData,
  getLatestLastBlockData: getLatestLastBlockData,
  getEarlistTimestampInThreshold: getEarlistTimestampInThreshold,
  pruneStaleBlockData: pruneStaleBlockData,
  rollBackToValidHash: rollBackToValidHash,
  getEarliestMultiChainTimestampInThreshold: getEarliestMultiChainTimestampInThreshold,
  getAllBlockNumbers: getAllBlockNumbers,
  hasReorgOccurred: hasReorgOccurred,
  rollBackToBlockNumberLt: rollBackToBlockNumberLt
};

exports.LastBlockScannedHashes = LastBlockScannedHashes;
/* No side effect */
